---
title: Tips
date: 2020-12-15 11:42:25
categories:
  - 笔记
tags:
  - 基础理论
---
## k8s

###  tips
    k8s系统将一切事物都抽象为api资源，其遵循rest架构风格组织并管理这些资源及其对象，同时还支持通过标准的http方法对资源进行增删改查等管理操作
    核心群组：rest路径为/api/v1
    命名的群组：rest路径为/apis/$GROUP_NAME/$VERSION，例如/apis/apps/v1



### Note


## 开发

### python

### go




## cloud

### aws

### 华为云


## 正则

### 模式
   贪婪,非贪婪,独占模式(贪婪情况直接匹配,不回溯,匹配失败直接报错,性能提升)

   正则不保存子组 \d{1}(?:\d{3})?   性能提升

   \b 表示单词边界   \babc\b  只能是abc

   环视匹配(零宽断言)  限制左右类型

   只有元字符组在字符组内不需要转义 如果存在其它转义\d等则存在转义




## 数据库

### redis

    技术点分析:
        高性能: 线程模型 网络模型 数据结构 持久化
        高可用: 主从 哨兵
        高可扩展: 分片 负载均衡
    技术维度:
        案例  点
        缓存技术 面

    redis 原理
        hash存储 链式哈希处理哈希冲突 数据量足够大
        redis 单线程模型
            -- 盲目多线程性能不一定提升 读写共享资源会带来额外的开销
            -- 互斥锁性能不够好

        正常网络IO阻塞点   accept recv     select+epoll 机制处理
        持久化
            -- AOF
               体现数据库数据落盘性能点 快慢的平衡
               AOF重写机制 统一最新数据  一处拷贝 两份日志(主线程fork子线程  一份直接写保证恢复 另一份重写完替换第一份)
                 主线程fork：
                     子线程拷贝主线程内存虚拟映射表 获取同一份内存数据 主线程更新内存数据 则新开辟内存空间 逐步数据分离
            -- RDB 内存快照
               内存拷贝
                  -- 阻塞
                  -- 非阻塞  新增数据复制管理 写入快照 (增量备份涉及到数据更新条数过多 浪费内存 配合AOF实现 AOF保存两次快照之间的数据)
                  -- CPU亲和性   fork出的子线程抢占父线程的cpu资源   如果存在cpu绑定



### sql优化


### mysql


## 消息中间件

### 整体
    通过客户端有序数字标记消息 服务端验证 确保消息可靠性


### rabbitmq

    堆积消息处理支持不够好,扩展和二次开发难度大 erlang语言过于偏    --开箱即用


### rocketmq

    比较全面,比rabbitmq性能高一个级别,不够流行,集成与兼容差些  --低延迟 稳定

### kafka

    kafka异步批量 针对大型结构更友好 在线实时业务的支持差些   -- 大数据



## os

### 整体
    实模式与保护模式    --应对兼容性   地址总线位数的增长


### linux


## 数据结构

### 线性表

1. 数组是连续内存空间(cpu访问方便 范围查询更快) 随机访问更方便 调整性能差   链表不需要连续空间 需要遍历访问 动态调整强(栈 队列 b+树 二叉树 等 两者变化和结合)
2. 二叉树 是链表与二分法的合并 检索上有提升  平衡二叉树是为了处理退化为链表的二叉树(无左节点)
3. 跳表 链表添加多指针(每隔2^n 个节点添加指针  --二分法)  需要在检索性能和调整数据上做平衡     --redis
4  hash表 字符串对应特定下标的数组 重复数据 依赖数据量采用红黑树或者链表  缺点(空间和范围查询) //  开放寻址法(冲突则线性探查(往后寻找空闲地址插入 --优化步长平衡空节点位置) 不能删除元素)
5  bitmap 处理状态类节省空间(无需存储信息)  与(and)运算判断值  通过多个哈希函数可以减少数组长度和冲突(布隆过滤器  缺点:删除和错误率)  [ 哈希函数最优个数 数组长度/对象个数*ln(2)]


    
